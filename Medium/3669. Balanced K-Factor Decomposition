class Solution {
    private int minele = Integer.MAX_VALUE;

    public int[] minDifference(int n, int k) {
        // Collecting divisors
        List<Integer> validList = new ArrayList<>();
        List<Integer> div = new ArrayList<>();
        div.add(1);
        for (int i = 2; i <= n; i++) {
            if (n % i == 0) {
                div.add(i);
            }
        }
        solve(n, k, div, 1, new ArrayList<>(), 0, validList);

        int ans[] = new int[validList.size()];
        for (int i = 0; i < validList.size(); i++) {
            ans[i] = validList.get(i);
        }
        return ans;
    }

    public void solve(int n, int k, List<Integer> div, int val, List<Integer> ls, int idx, List<Integer> validList) {
        if (val > n) {
            return;
        }
        if (ls.size() > k) {
            return;
        }

        if (ls.size() == k) {
            if (val == n) {
                int max = Collections.max(ls);
                int min = Collections.min(ls);

                int diff = max - min;
                if (diff < minele) {
                    minele = diff;
                    validList.clear();
                    validList.addAll(ls);
                }
            }
            return;
        }
        if (idx >= div.size()) {
            return;
        }

        ls.add(div.get(idx)); // add the particular element into the list
        solve(n, k, div, val * div.get(idx), ls, idx, validList); // recursive call for reuse of that particular element
        ls.remove(ls.size() - 1);
        solve(n, k, div, val, ls, idx + 1, validList); // skip the idx
    }
}
